\chapter*{Conclusion}\label{chapter:Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}
It is time to look back at the work that has been done, to highlight the progress that has been made, but also the shortcomings and gaps that need to be filled by future improvements. We will therefore use this chapter to discuss some of the key points that emerge from this thesis.

The aim of this thesis was to succeed in formalising Gradus ad Parnassum by J.J. Fux, a baroque composer who lived in the 18th century, in order to have an exhaustive record of the rules he imparts in his work. These rules concern the composition of counterpoint. More specifically, the aim of this work was to generalise the existing formalisation for two voices to three voices. Once formalised, these rules were to be implemented in the form of a constraint solving problem, which would then make it possible to obtain automatically generated counterpoints. The result of this work should be expressed in the form of a highly customisable tool, in order to provide the user-composer with an easy-to-use tool that can assist them in their composition of counterpoint. Looking at what has been done, we consider that these benchmarks have been reached. The rules have been formalised in the most unambiguous way possible (firstly, through precise formulation in English, and secondly, through the use of logical formulae), and then implemented in the form of the FuxCP tool, which is capable of automatically generating counterpoints. 

\paragraph{}
To be able to express Fux's rules in formal logic, it was necessary to create new concepts and variables, and even to change the paradigm: the cantus firmus lost its place of honour to the lowest stratum, i.e. the lowest note at any given moment. We can be pleased that the formalisation for three voices maintains full compatibility with the two-part formalisation, and that the new variables and concepts introduced can also be used by the two-part formalised rules.


The implementation, which uses GiL to call the Gecode tool from Lisp, is also functional and allows anyone to generate counterpoints in a matter of seconds. While the musical results of these generations must be qualified, as they are not always masterpieces, they are a good basis and the current implementation can be considered successful. A major drawback of the current implementation is the cases where the solver has difficulty finding a solution, in which case the waiting time to obtain counterpoints can be long (on the order of several minutes). This is relatively harmless at the moment, but it could become a problem if we continue to add constraints by adding voices.
With regard to the possibility of customisation by the composer-user, a great deal of thought has been given to the best way of enabling the constraint solver to understand human preferences. This reflection has led to the conclusion that each user must be as free as possible to manage the costs of the search in order to be able to engage in iterative composition: they make a first attempt, observe the result, adjust the costs and try again, and so on. The interface reflects this policy and allows the user to manipulate the costs with great flexibility. 

As far as the practical side of the implementation is concerned, a major limitation in the development of the tool was the restrictive aspect of coding in Lisp a programme that would be much easier to code in object-oriented programming. Coding Gecode in Lisp is error prone (as it is much more verbose and less clear) and time consuming. If a potential successor to this work were to change one thing immediately, it would be to continue directly in C++.

\paragraph{}
In a more global perspective, we can think about the implications of this work for the future.
First of all, last year T. Wafflard demonstrated the relevance of using constraint programming in the field of musical composition and more specifically in counterpoint. This work confirms this conclusion.
Secondly, by following in the footsteps of previous work on counterpoint, music and constraint programming, and by adding its own contribution to this long line, this work contributes to the creation, perhaps one day, of a tool perfectly capable of generating highly customisable, multi-voice counterpoints on complete musical compositions. Far from replacing composers, this tool would be an excellent tool for beginners, giving them a solid base to build on, and a source of inspiration for the more experienced, who could play with different preferences to produce innovative compositions.

While there's still a considerable journey ahead, the building is steadily taking shape, brick by brick.